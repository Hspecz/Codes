//======================
// 
// Adding Custom Element - Prismatic (Riggo)
// 
//======================
This modification introduces a new Element ID ELE_PRISMATIC.
It bypasses the standard attribute table to apply specific hardcoded rules:

Vs All Others (Offense): Deals +50% damage (150% Total).

Vs All Others (Defense): Takes -30% damage (70% Total).

Prismatic vs Prismatic: Deals +300% damage (400% Total).

1. Define the New Element ID

File: src/map/status.hpp

Find: (Look for enum e_element)

	ELE_GHOST,
	ELE_UNDEAD,
	ELE_ALL,
	ELE_MAX,


Add BEFORE ELE_ALL or ELE_MAX:
Important: We assign it the next available ID (usually 10). Do not place it after ELE_MAX.

	ELE_PRISMATIC, // Custom Element


2. Implement Battle Logic (The Multipliers)

We will modify the function that calculates elemental damage percentages to intercept checks for Prismatic.

File: src/map/battle.cpp

Find: int battle_attr_fix(struct block_list *src, struct block_list *target, int damage, int ele, int type, int flag)
(Note: In some versions, this might be named battle_calc_attr_fix or similar. Look for the function that references attr_fix_table)

Find inside the function:

	if (ele < ELE_NEUTRAL || ele >= ELE_MAX)
		return 100;


Add BELOW that check:

	// --- Custom Element: Prismatic Logic ---
	
	int target_ele = status_get_element(target);

	// Rule 1 & 3: Attacker is Prismatic
	if (ele == ELE_PRISMATIC) {
		// If hitting Prismatic Armor -> 300% MORE damage (400% total)
		if (target_ele == ELE_PRISMATIC)
			return 400;
		
		// If hitting anything else -> 50% MORE damage (150% total)
		return 150;
	}

	// Rule 2: Defender is Prismatic (and Attacker is NOT Prismatic, handled above)
	if (target_ele == ELE_PRISMATIC) {
		// Receives 30% LESS damage (70% total)
		return 70;
	}

	// ---------------------------------------


Why this works: By returning a value here, we skip the standard attr_fix_table lookup entirely for this element, saving you from editing hundreds of database lines.

3. Register for Scripting

To allow you to use this element in scripts (e.g., npc_setele, item bonuses).

File: src/map/script_constants.hpp

Find: ELE_UNDEAD
Add Below:

	export_constant(ELE_PRISMATIC);


4. Database Update

File: db/re/const.txt (and db/pre-re/const.txt)

Add at the end:

Ele_Prismatic	10


(Note: Verify the ID number. If ELE_UNDEAD is 9, then Prismatic is 10).

5. How to Use

As an Item Bonus (Armor)

To make an armor Prismatic:

{ bonus bDefEle, Ele_Prismatic; }


As an Item Bonus (Weapon)

To make a weapon Prismatic:

{ bonus bAtkEle, Ele_Prismatic; }


As a Monster Attribute

To make a monster Prismatic, you can edit mob_db.yml:

  - Id: 1002
    AegisName: PORING
    Name: Prismatic Poring
    Element: Prismatic  # This requires updating libconfig mappings, or just use the ID:
    Element: 10         # Safer method
    ElementLevel: 1


6. Optional: Add to NPC_RANDOMATTACK

This allows monsters using the generic NPC_RANDOMATTACK skill to randomly roll the Prismatic element (ID 10).

File: src/map/battle.cpp

Find: (Inside battle_get_attr or similar function)

	if (skill_id == NPC_RANDOMATTACK)
		return rnd() % 10; // Standard is 0-9 (Neutral to Undead)


Change to:

	if (skill_id == NPC_RANDOMATTACK)
		return rnd() % 11; // Increase to 11 to include ID 10 (Prismatic)
